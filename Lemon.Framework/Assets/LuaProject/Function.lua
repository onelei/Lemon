---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by onelei.
--- DateTime: 2020/8/2 15:57
---

function class(classname, super)
    local superType = type(super)
    local cls

    if superType ~= "function" and superType ~= "table" then
        superType = nil
        super = nil
    end

    if superType == "function" or (super and super.__ctype == 1) then
        -- inherited from native C++ Object
        cls = {}

        if superType == "table" then
            -- copy fields from super
            for k,v in pairs(super) do cls[k] = v end
            cls.__create = super.__create
            cls.super    = super
        else
            cls.__create = super
            cls.ctor = function() end
        end

        cls.__cname = classname
        cls.__ctype = 1

        function cls.new(...)
            local instance = cls.__create(...)
            -- copy fields from class to native object
            for k,v in pairs(cls) do instance[k] = v end
            instance.class = cls
            instance:ctor(...)
            return instance
        end

    else
        -- inherited from Lua Object
        if super then
            cls = {}
            setmetatable(cls, {__index = super})
            cls.super = super
        else
            cls = {ctor = function() end}
        end

        cls.__cname = classname
        cls.__ctype = 2 -- lua
        cls.__index = cls

        function cls.new(...)
            local instance = setmetatable({}, cls)
            instance.class = cls
            instance:ctor(...)
            return instance
        end
    end

    return cls
end

---- 声明一个 lua class
---- className 是类名
---- super 为父类
--function class(className, super)
--    -- 构建类
--    local clazz = { __cname = className, super = super }
--    if super then
--        -- 设置类的元表，此类中没有的，可以查找父类是否含有
--        setmetatable(clazz, { __index = super })
--    end
--    -- new 方法创建类对象
--    clazz.new = function(...)
--        -- 构造一个对象
--        local instance = {}
--        -- 设置对象的元表为当前类，这样，对象就可以调用当前类生命的方法了
--        setmetatable(instance, { __index = clazz })
--        if clazz.ctor then
--            clazz.ctor(instance, ...)
--        end
--        return instance
--    end
--    return clazz
--end

-----云风
--local _class={}
--function class(classname,super)
--    local class_type={}
--    class_type.classname = classname
--    class_type.ctor     = false
--    class_type.super    = super
--    class_type.new      =
--    function(...)
--        local obj={}
--        do
--            local create
--            create = function(c,...)
--                if c.super then
--                    create(c.super,...)
--                end
--                if c.ctor then
--                    c.ctor(obj,...)
--                end
--            end
--
--            create(class_type,...)
--        end
--        setmetatable(obj,{ __index = _class[class_type] })
--        return obj
--    end
--    local vtbl={}
--    _class[class_type]=vtbl
--
--    setmetatable(class_type,{__newindex=
--                             function(t,k,v)
--                                 vtbl[k]=v
--                             end
--    })
--
--    if super then
--        setmetatable(vtbl,{__index=
--                           function(t,k)
--                               local ret=_class[super][k]
--                               vtbl[k]=ret
--                               return ret
--                           end
--        })
--    end
--
--    ---class_type.new()
--    return class_type
--end