# 🎮 输入录制系统使用指南

## 概述

这是一个**基于输入记录的录像系统**，与传统的全状态录像不同，它只记录玩家的输入操作，播放时通过ECS系统重新计算游戏状态。这种方法可以**大幅减小文件体积**，非常适合网络游戏回放和长时间录制。

## 🆚 两种录像系统对比

### 全状态录像（ReplayData）
- **原理**：每帧记录完整的游戏状态（所有实体和组件）
- **优点**：
  - 播放时直接恢复状态，速度快
  - 可以任意跳转，无需重新计算
  - 不依赖确定性
- **缺点**：
  - 文件非常大（每帧都保存完整数据）
  - 不适合长时间录制
  - 网络传输成本高

### 输入录像（InputReplayData）✨推荐
- **原理**：只记录玩家输入，保存初始状态，播放时重新执行System
- **优点**：
  - **文件极小**（只记录有输入的帧）
  - 适合长时间录制
  - 适合网络传输
  - 压缩率可达90%以上
- **缺点**：
  - 需要确定性系统（相同输入必须产生相同结果）
  - 跳转需要从头重新计算
  - 播放速度稍慢（需要执行System）

## 📊 文件大小对比示例

假设60秒的游戏录像（3600帧）：

| 系统类型 | 文件大小 | 说明 |
|---------|---------|------|
| 全状态录像 | ~5-10 MB | 每帧保存完整状态 |
| 输入录像 | ~50-200 KB | 只保存输入帧（压缩率90%+） |

**节省空间：95%以上！**

## 🚀 快速开始

### 1. 运行Demo

1. 在Unity中创建空GameObject
2. 添加 `InputReplayDemo` 组件
3. 点击Play运行
4. 使用右侧按钮控制录制和播放

### 2. 基本操作

**录制：**
```
开始录制 → WASD移动 → 停止录制 → 保存录像
```

**播放：**
```
加载录像 → 播放 → 观察输入被重放
```

## 💻 代码集成

### 录制输入

```csharp
using LemonFramework.ECS.Replay;

// 创建录制器
InputRecorder recorder = new InputRecorder(world);

// 开始录制
recorder.StartRecording("我的录像", targetFrameRate: 60);

// 每帧记录输入
Vector2 movement = GetPlayerInput(); // 获取WASD输入
recorder.RecordInput(movement);

// 停止录制
InputReplayData replay = recorder.StopRecording();

// 保存到文件
recorder.SaveReplay("input_replay.dat");
```

### 播放输入

```csharp
// 创建播放器
InputPlayer player = new InputPlayer(world);

// 加载录像
player.LoadReplayFromFile("input_replay.dat");

// 开始播放
player.Play();

// 每帧更新（会自动执行System和应用输入）
player.Update(Time.deltaTime);

// 获取当前帧的输入
Vector2 currentInput = player.CurrentInput.Movement;

// 控制播放
player.SetPlaybackSpeed(2.0f);  // 2倍速
player.SeekToProgress(0.5f);     // 跳转到50%
player.Pause();
player.Stop();
```

### 创建支持输入的System

关键是System需要从外部获取输入，而不是直接读取Input类：

```csharp
public class PlayerInputMovementSystem : ComponentSystem
{
    private InputReplayDemo _demo;  // 引用Demo获取输入
    
    public PlayerInputMovementSystem(InputReplayDemo demo)
    {
        _demo = demo;
    }
    
    protected override void OnUpdate(TimeData timeData)
    {
        var entity = _demo.GetControlledEntity();
        var input = _demo.GetCurrentInput();  // 从Demo获取输入
        
        if (ComponentManager.TryGetComponent(entity, out EcsTransform transform))
        {
            float speed = 0.083f;
            Vector3 movement = new Vector3(input.x, input.y, 0) * speed;
            transform.Position += movement;
            ComponentManager.SetComponent(entity, transform);
        }
    }
}
```

## 🔧 核心类说明

### FrameInput

单帧的输入数据结构：

```csharp
public struct FrameInput
{
    public int FrameNumber;      // 帧号
    public Vector2 Movement;     // 移动输入
    public int ButtonStates;     // 按键状态（可扩展）
}
```

### InputReplayData

输入录像数据类：

**属性：**
- `ReplayName` - 录像名称
- `StartFrame/EndFrame` - 开始/结束帧号
- `TotalFrames` - 总帧数
- `InputFrameCount` - 有输入的帧数（压缩指标）
- `InitialSnapshot` - 初始状态快照
- `TargetFrameRate` - 目标帧率
- `Duration` - 时长

**方法：**
- `AddInput(input)` - 添加输入（只记录非空输入）
- `GetInput(frameNumber)` - 获取指定帧的输入
- `SaveToFile(path)` - 保存到文件
- `LoadFromFile(path)` - 从文件加载

### InputRecorder

输入录制器：

**属性：**
- `IsRecording` - 是否正在录制
- `RecordedFrames` - 总帧数
- `InputFrameCount` - 输入帧数

**方法：**
- `StartRecording(name, fps)` - 开始录制
- `RecordInput(movement)` - 记录输入
- `StopRecording()` - 停止录制
- `SaveReplay(path)` - 保存录像

### InputPlayer

输入播放器：

**属性：**
- `IsPlaying` - 是否播放中
- `PlaybackSpeed` - 播放速度
- `CurrentFrame` - 当前帧
- `CurrentInput` - 当前输入
- `Progress` - 播放进度

**方法：**
- `LoadReplay(data)` - 加载录像
- `Play/Pause/Stop()` - 播放控制
- `Update(deltaTime)` - 更新播放
- `SeekToFrame/Progress/Time()` - 跳转
- `StepForward/Backward()` - 逐帧

## 📐 工作原理

### 录制流程

```
1. 创建初始快照（保存起始状态）
2. 每帧读取玩家输入
3. 如果输入不为空，记录输入数据
4. 停止时保存：初始快照 + 输入序列
```

### 播放流程

```
1. 加载初始快照恢复起始状态
2. 从StartFrame开始逐帧：
   a. 获取该帧的输入
   b. 将输入传递给System
   c. 执行System.Update()
   d. System根据输入计算新状态
3. 重复直到EndFrame
```

### 为什么文件小？

```
传统方式：每帧保存完整状态
帧0: [Entity1数据, Entity2数据, ...]  -> 1KB
帧1: [Entity1数据, Entity2数据, ...]  -> 1KB
帧2: [Entity1数据, Entity2数据, ...]  -> 1KB
...
3600帧 = 3.6 MB

输入方式：只保存初始状态 + 输入
初始: [完整状态]                    -> 1KB
帧10: [输入: WASD]                 -> 12字节
帧15: [输入: WASD]                 -> 12字节
帧23: [输入: W]                    -> 12字节
...
100个输入帧 = 1KB + 1.2KB = 2.2KB

压缩率 = (3600KB - 2.2KB) / 3600KB = 99.9%！
```

## ⚠️ 确定性要求

输入录像要求游戏逻辑是**确定性**的：

### ✅ 确定性做法

```csharp
// 使用固定的时间步长
float fixedDeltaTime = 1f / 60f;
position += velocity * fixedDeltaTime;

// 使用相同的随机种子
Random.InitState(12345);
```

### ❌ 非确定性做法（避免）

```csharp
// 使用Unity的Time.deltaTime（会变化）
position += velocity * Time.deltaTime;

// 使用时间作为随机种子
Random.InitState((int)DateTime.Now.Ticks);

// 使用非确定性物理
// 浮点运算顺序不一致
```

## 🎯 适用场景

### 推荐使用输入录像的场景

1. **网络游戏回放** - 文件小，易于传输
2. **长时间录制** - 可以录制数小时
3. **竞技游戏复盘** - 精确重现操作
4. **AI训练数据** - 收集玩家操作
5. **自动化测试** - 回放测试用例

### 推荐使用全状态录像的场景

1. **调试工具** - 需要快速任意跳转
2. **短时间精彩瞬间** - 文件大小可接受
3. **非确定性游戏** - 有随机元素
4. **视频录制** - 需要完美重现画面

## 🔄 两种系统对比表

| 特性 | 输入录像 | 全状态录像 |
|-----|---------|-----------|
| 文件大小 | ⭐⭐⭐⭐⭐ 极小 | ⭐ 很大 |
| 播放速度 | ⭐⭐⭐ 中等 | ⭐⭐⭐⭐⭐ 很快 |
| 跳转速度 | ⭐⭐ 需重算 | ⭐⭐⭐⭐⭐ 瞬间 |
| 网络传输 | ⭐⭐⭐⭐⭐ 优秀 | ⭐ 困难 |
| 长时间录制 | ⭐⭐⭐⭐⭐ 可行 | ⭐ 不可行 |
| 确定性要求 | 必须 | 不需要 |
| 实现复杂度 | ⭐⭐⭐⭐ 较高 | ⭐⭐ 简单 |

## 💡 优化技巧

### 1. 减少输入记录频率

只记录输入变化的帧：

```csharp
Vector2 lastInput = Vector2.zero;
Vector2 currentInput = GetInput();

if (currentInput != lastInput)
{
    recorder.RecordInput(currentInput);
    lastInput = currentInput;
}
```

### 2. 压缩输入数据

使用更小的数据类型：

```csharp
// 使用byte代替float（如果精度允许）
byte inputX = (byte)((input.x + 1f) * 127.5f);  // -1到1映射到0-255
```

### 3. 分段保存

超长录像分段保存：

```csharp
if (recordedFrames % 18000 == 0)  // 每5分钟保存一次
{
    recorder.SaveReplay($"replay_part{partIndex++}.dat");
    recorder.StartRecording("NextPart");
}
```

## 🐛 常见问题

### Q: 播放时结果和录制时不一样？
A: 检查是否满足确定性要求：
- 使用固定时间步长
- 不要使用Time.deltaTime
- 确保随机数种子固定
- 避免多线程竞争

### Q: 跳转很慢怎么办？
A: 输入录像跳转需要从头计算，可以：
- 定期保存关键帧快照
- 使用全状态录像替代
- 优化System性能

### Q: 文件还是太大？
A: 进一步优化：
- 只记录输入变化
- 压缩输入数据
- 使用更低的采样率

### Q: 如何录制多个玩家？
A: 扩展InputData结构：

```csharp
public struct MultiPlayerInput
{
    public Dictionary<int, FrameInput> PlayerInputs;
}
```

## 📚 示例代码

完整示例请参考：
- `InputReplayDemo.cs` - 完整的Demo实现
- `PlayerInputMovementSystem.cs` - 输入驱动的System示例

## 🎉 总结

输入录像系统是一个**轻量级、高效**的录像解决方案，特别适合：
- 需要长时间录制的场景
- 网络游戏回放
- 竞技游戏分析
- AI训练数据收集

通过**只记录输入**的方式，可以将文件大小减小到原来的1%以下，同时保持完整的游戏重现能力。

**选择建议：**
- 确定性游戏 + 需要小文件 → 使用输入录像 ✅
- 非确定性游戏 + 短时录制 → 使用全状态录像

祝您使用愉快！🎮

