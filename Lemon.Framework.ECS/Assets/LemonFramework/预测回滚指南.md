# 预测回滚系统指南

## 概述

预测回滚（Prediction & Rollback）是网络游戏中常用的技术，用于处理网络延迟和保证游戏体验的流畅性。

## 工作原理

```
时间线：
0────30────60────90────120 (帧)
│    │     │     │     │
S1   S2    S3    S4    S5  (快照)

玩家操作：
├─移动─┤
       ↓
     预测结果

服务器确认：
├────延迟────┤
            ↓
          实际结果 ≠ 预测结果
            ↓
         回滚到S2
            ↓
         重放到当前帧
```

## 核心机制

### 1. 快照创建

```csharp
// 每隔N帧自动创建快照
if (currentFrame - lastSnapshotFrame >= snapshotInterval)
{
    var snapshot = world.CreateSnapshot();
    snapshotQueue.Enqueue(snapshot);
}
```

### 2. 快照队列管理

```csharp
// 限制快照数量（环形队列）
while (snapshotQueue.Count > maxSnapshots)
{
    var oldSnapshot = snapshotQueue.Dequeue();
    snapshotManager.RemoveSnapshot(oldSnapshot.SnapshotId);
}
```

### 3. 回滚操作

```csharp
// 回滚到指定帧
void RollbackFrames(int frames)
{
    int targetFrame = currentFrame - frames;
    
    // 找到最接近的快照
    SceneSnapshot targetSnapshot = FindClosestSnapshot(targetFrame);
    
    // 恢复快照
    world.RestoreFromSnapshot(targetSnapshot);
    timeData.Frame = targetSnapshot.FrameNumber;
    
    // 重放输入到当前帧（如果需要）
    ReplayInputs(targetSnapshot.FrameNumber, currentFrame);
}
```

## Demo 使用说明

### 启动Demo

1. 将 `PredictionRollbackDemo.cs` 添加到场景中的GameObject
2. 运行场景

### 控制说明

**键盘控制**
- `W` - 向前移动红色立方体
- `S` - 向后移动红色立方体
- `A` - 向左移动红色立方体
- `D` - 向右移动红色立方体

**UI按钮**
- `回滚 60 帧 (1秒)` - 回滚到1秒前的状态
- `回滚 120 帧 (2秒)` - 回滚到2秒前的状态
- `回滚到最早快照` - 回滚到最早保存的快照
- `保存快照到文件` - 将当前状态保存到磁盘
- `从文件加载快照` - 从磁盘加载之前保存的状态
- `快照列表` - 点击任意快照直接恢复到该状态

### 测试场景

#### 场景1：基础回滚测试
1. 运行Demo，使用WASD移动红色立方体
2. 移动一段距离后，点击"回滚60帧"
3. 观察红色立方体回到之前的位置
4. 其他立方体的动画状态也会回滚

#### 场景2：多次回滚测试
1. 持续移动红色立方体
2. 多次点击回滚按钮
3. 观察场景状态在不同时间点之间切换

#### 场景3：保存和加载测试
1. 移动到特定位置
2. 点击"保存快照到文件"
3. 继续移动和操作
4. 点击"从文件加载快照"
5. 观察场景恢复到保存时的状态

## 参数配置

### Inspector参数

```csharp
[Header("ECS设置")]
public int entityCount = 50;          // 实体数量
public GameObject entityPrefab;       // 实体预制体

[Header("快照设置")]
public int snapshotInterval = 30;     // 快照间隔（帧）
public int maxSnapshots = 10;         // 最多保留快照数

[Header("回滚测试")]
public int rollbackFrames = 60;       // 回滚帧数
```

### 性能建议

**快照间隔**
- 更小的间隔：更精确的回滚，但内存占用更大
- 推荐值：30帧（0.5秒 @ 60fps）
- 网络游戏：根据网络延迟调整（通常50-100ms）

**快照数量**
- 取决于需要回滚的最大时间范围
- 公式：`maxSnapshots = (最大回滚秒数 * 60) / snapshotInterval`
- 例如：支持5秒回滚，间隔30帧 → `maxSnapshots = (5 * 60) / 30 = 10`

**内存占用估算**
```
单个快照大小 ≈ 实体数 × 组件大小 × 组件数量
例如：
- 100个实体
- 每个实体1个Transform组件（约40字节）
- 单快照 ≈ 100 × 40 = 4KB
- 10个快照 ≈ 40KB
```

## 实际应用场景

### 网络游戏客户端预测

```csharp
// 客户端预测
void HandleLocalInput(InputData input)
{
    // 1. 立即应用输入（预测）
    ApplyInput(localPlayer, input);
    
    // 2. 发送输入到服务器
    SendInputToServer(input);
    
    // 3. 等待服务器确认...
}

// 服务器确认后
void OnServerConfirmation(int confirmedFrame, StateData serverState)
{
    // 1. 回滚到确认帧
    RollbackToFrame(confirmedFrame);
    
    // 2. 应用服务器权威状态
    ApplyServerState(serverState);
    
    // 3. 重放本地输入
    ReplayInputs(confirmedFrame, currentFrame);
}
```

### 确定性回放系统

```csharp
// 录制：保存快照和输入
void Record()
{
    if (frame % snapshotInterval == 0)
    {
        RecordSnapshot();
    }
    RecordInput();
}

// 回放：加载快照，重放输入
void Replay()
{
    LoadSnapshot(startFrame);
    for (int f = startFrame; f < endFrame; f++)
    {
        ApplyRecordedInput(f);
        UpdateECS();
    }
}
```

### 存档系统

```csharp
// 保存游戏
void SaveGame(string saveSlot)
{
    var snapshot = world.CreateSnapshot();
    world.SaveSnapshotToFile(snapshot.SnapshotId, $"save_{saveSlot}.dat");
}

// 加载游戏
void LoadGame(string saveSlot)
{
    var snapshot = world.LoadSnapshotFromFile($"save_{saveSlot}.dat");
    world.RestoreFromSnapshot(snapshot);
}
```

## 高级技巧

### 1. 增量快照

```csharp
// 只保存变化的组件
public class IncrementalSnapshot
{
    public int BaseSnapshotId;
    public Dictionary<int, object> ChangedComponents;
}
```

### 2. 快照压缩

```csharp
// 使用压缩减少内存占用
public byte[] CompressSnapshot(byte[] data)
{
    // 使用GZip或LZ4压缩
    return Compress(data);
}
```

### 3. 预测误差检测

```csharp
// 比较预测结果和服务器结果
void CheckPredictionError(StateData predicted, StateData actual)
{
    float error = CalculateError(predicted, actual);
    if (error > threshold)
    {
        // 误差过大，需要回滚
        RollbackAndCorrect();
    }
}
```

### 4. 时间戳同步

```csharp
// 使用时间戳而不是帧号
public class TimestampedSnapshot
{
    public long Timestamp; // Unix时间戳
    public SceneSnapshot Snapshot;
}
```

## 常见问题

**Q: 回滚会影响玩家体验吗？**

A: 如果处理得当，玩家几乎察觉不到。关键是：
- 只回滚必要的部分
- 使用插值平滑过渡
- 优化快照创建性能

**Q: 如何处理非确定性行为（如随机数）？**

A: 两种方案：
1. 使用固定种子的伪随机数
2. 在快照中保存随机数生成器状态

**Q: 多人游戏如何处理？**

A: 
- 客户端：本地预测 + 回滚纠正
- 服务器：权威状态 + 快照广播
- 延迟补偿：服务器保存历史快照

**Q: 性能开销大吗？**

A: 取决于实现：
- 快照创建：取决于序列化效率（我们使用二进制序列化，很快）
- 内存占用：取决于快照数量和大小（通常几KB到几MB）
- CPU占用：主要在回滚时（极少发生）

## 扩展建议

1. **网络层集成**
   - 添加客户端-服务器通信
   - 实现输入同步
   - 延迟补偿

2. **可视化工具**
   - 快照时间轴可视化
   - 状态差异对比
   - 回滚路径显示

3. **调试功能**
   - 慢速回放
   - 单步调试
   - 状态检查器

4. **优化**
   - 多线程快照创建
   - 快照池复用
   - 差分快照

## 参考资源

- [Overwatch网络架构](https://www.gdcvault.com/play/1024001/)
- [Rocket League的确定性网络](https://www.gdcvault.com/play/1022188/)
- [Fighting Game网络代码](https://ki.infil.net/w02-netcode.html)

## 完整示例代码

查看 `PredictionRollbackDemo.cs` 获取完整的实现代码。

